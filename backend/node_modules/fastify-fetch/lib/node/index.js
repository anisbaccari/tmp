import assert from 'node:assert';
import { promisify } from 'node:util';
import { gunzip as gunzip$1, brotliDecompress as brotliDecompress$1, inflate as inflate$1 } from 'node:zlib';
import { Request, Response, fetch, Headers } from 'undici';
import { getResponseState } from 'undici/lib/web/fetch/response.js';

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp(target, "default", { value: mod, enumerable: true }) ,
  mod
));

// node_modules/.pnpm/data-uri-to-buffer@6.0.2/node_modules/data-uri-to-buffer/dist/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/data-uri-to-buffer@6.0.2/node_modules/data-uri-to-buffer/dist/common.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeDataUriToBuffer = void 0;
    var makeDataUriToBuffer = (convert) => (uri) => {
      uri = String(uri);
      if (!/^data:/i.test(uri)) {
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
      }
      uri = uri.replace(/\r?\n/g, "");
      const firstComma = uri.indexOf(",");
      if (firstComma === -1 || firstComma <= 4) {
        throw new TypeError("malformed data: URI");
      }
      const meta = uri.substring(5, firstComma).split(";");
      let charset = "";
      let base64 = false;
      const type = meta[0] || "text/plain";
      let typeFull = type;
      for (let i = 1; i < meta.length; i++) {
        if (meta[i] === "base64") {
          base64 = true;
        } else if (meta[i]) {
          typeFull += `;${meta[i]}`;
          if (meta[i].indexOf("charset=") === 0) {
            charset = meta[i].substring(8);
          }
        }
      }
      if (!meta[0] && !charset.length) {
        typeFull += ";charset=US-ASCII";
        charset = "US-ASCII";
      }
      const data = unescape(uri.substring(firstComma + 1));
      const buffer = base64 ? convert.base64ToArrayBuffer(data) : convert.stringToBuffer(data);
      return {
        type,
        typeFull,
        charset,
        buffer
      };
    };
    exports.makeDataUriToBuffer = makeDataUriToBuffer;
  }
});

// node_modules/.pnpm/data-uri-to-buffer@6.0.2/node_modules/data-uri-to-buffer/dist/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/data-uri-to-buffer@6.0.2/node_modules/data-uri-to-buffer/dist/node.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dataUriToBuffer = void 0;
    var common_1 = require_common();
    function nodeBuffertoArrayBuffer(nodeBuf) {
      if (nodeBuf.byteLength === nodeBuf.buffer.byteLength) {
        return nodeBuf.buffer;
      }
      const buffer = new ArrayBuffer(nodeBuf.byteLength);
      const view = new Uint8Array(buffer);
      view.set(nodeBuf);
      return buffer;
    }
    function base64ToArrayBuffer(base64) {
      return nodeBuffertoArrayBuffer(Buffer.from(base64, "base64"));
    }
    function stringToBuffer(str) {
      return nodeBuffertoArrayBuffer(Buffer.from(str, "ascii"));
    }
    exports.dataUriToBuffer = (0, common_1.makeDataUriToBuffer)({ stringToBuffer, base64ToArrayBuffer });
  }
});

// node_modules/.pnpm/fastify-plugin@5.0.1/node_modules/fastify-plugin/lib/getPluginName.js
var require_getPluginName = __commonJS({
  "node_modules/.pnpm/fastify-plugin@5.0.1/node_modules/fastify-plugin/lib/getPluginName.js"(exports, module) {
    var fpStackTracePattern = /at\s{1}(?:.*\.)?plugin\s{1}.*\n\s*(.*)/;
    var fileNamePattern = /(\w*(\.\w*)*)\..*/;
    module.exports = function getPluginName(fn) {
      if (fn.name.length > 0) return fn.name;
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 10;
      try {
        throw new Error("anonymous function");
      } catch (e) {
        Error.stackTraceLimit = stackTraceLimit;
        return extractPluginName(e.stack);
      }
    };
    function extractPluginName(stack) {
      const m = stack.match(fpStackTracePattern);
      return m ? m[1].split(/[/\\]/).slice(-1)[0].match(fileNamePattern)[1] : "anonymous";
    }
    module.exports.extractPluginName = extractPluginName;
  }
});

// node_modules/.pnpm/fastify-plugin@5.0.1/node_modules/fastify-plugin/lib/toCamelCase.js
var require_toCamelCase = __commonJS({
  "node_modules/.pnpm/fastify-plugin@5.0.1/node_modules/fastify-plugin/lib/toCamelCase.js"(exports, module) {
    module.exports = function toCamelCase(name) {
      if (name[0] === "@") {
        name = name.slice(1).replace("/", "-");
      }
      return name.replace(/-(.)/g, function(match2, g1) {
        return g1.toUpperCase();
      });
    };
  }
});

// node_modules/.pnpm/fastify-plugin@5.0.1/node_modules/fastify-plugin/plugin.js
var require_plugin = __commonJS({
  "node_modules/.pnpm/fastify-plugin@5.0.1/node_modules/fastify-plugin/plugin.js"(exports, module) {
    var getPluginName = require_getPluginName();
    var toCamelCase = require_toCamelCase();
    var count = 0;
    function plugin(fn, options = {}) {
      let autoName = false;
      if (fn.default !== void 0) {
        fn = fn.default;
      }
      if (typeof fn !== "function") {
        throw new TypeError(
          `fastify-plugin expects a function, instead got a '${typeof fn}'`
        );
      }
      if (typeof options === "string") {
        options = {
          fastify: options
        };
      }
      if (typeof options !== "object" || Array.isArray(options) || options === null) {
        throw new TypeError("The options object should be an object");
      }
      if (options.fastify !== void 0 && typeof options.fastify !== "string") {
        throw new TypeError(`fastify-plugin expects a version string, instead got '${typeof options.fastify}'`);
      }
      if (!options.name) {
        autoName = true;
        options.name = getPluginName(fn) + "-auto-" + count++;
      }
      fn[Symbol.for("skip-override")] = options.encapsulate !== true;
      fn[Symbol.for("fastify.display-name")] = options.name;
      fn[Symbol.for("plugin-meta")] = options;
      if (!fn.default) {
        fn.default = fn;
      }
      const camelCase = toCamelCase(options.name);
      if (!autoName && !fn[camelCase]) {
        fn[camelCase] = fn;
      }
      return fn;
    }
    module.exports = plugin;
    module.exports.default = plugin;
    module.exports.fastifyPlugin = plugin;
  }
});

// src/fastify-fetch.ts
var import_data_uri_to_buffer = __toESM(require_node());
var import_fastify_plugin = __toESM(require_plugin());
function splitCookiesString(cookiesString) {
  const cookiesStrings = [];
  let pos = 0;
  let start;
  let ch;
  let lastComma;
  let nextStart;
  let cookiesSeparatorFound;
  function skipWhitespace() {
    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
      pos += 1;
    }
    return pos < cookiesString.length;
  }
  function notSpecialChar() {
    ch = cookiesString.charAt(pos);
    return ch !== "=" && ch !== ";" && ch !== ",";
  }
  while (pos < cookiesString.length) {
    start = pos;
    cookiesSeparatorFound = false;
    while (skipWhitespace()) {
      ch = cookiesString.charAt(pos);
      if (ch === ",") {
        lastComma = pos;
        pos += 1;
        skipWhitespace();
        nextStart = pos;
        while (pos < cookiesString.length && notSpecialChar()) {
          pos += 1;
        }
        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
          cookiesSeparatorFound = true;
          pos = nextStart;
          cookiesStrings.push(cookiesString.substring(start, lastComma));
          start = pos;
        } else {
          pos = lastComma + 1;
        }
      } else {
        pos += 1;
      }
    }
    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
    }
  }
  return cookiesStrings;
}
function fromNodeHeaders(nodeHeaders) {
  const headers = new Headers();
  for (const [key, value] of Object.entries(nodeHeaders)) {
    const values = Array.isArray(value) ? value : [value];
    for (let v of values) {
      if (v === void 0) continue;
      if (typeof v === "number") {
        v = v.toString();
      }
      headers.append(key, v);
    }
  }
  return headers;
}
function toNodeHeaders(headers) {
  const nodeHeaders = {};
  const cookies = [];
  if (headers) {
    for (const [key, value] of headers.entries()) {
      if (key.toLowerCase() === "set-cookie") {
        cookies.push(...splitCookiesString(value));
        nodeHeaders[key] = cookies.length === 1 ? cookies[0] : cookies;
      } else {
        nodeHeaders[key] = value;
      }
    }
  }
  return nodeHeaders;
}

// src/fastify-fetch.ts
var gunzip = promisify(gunzip$1);
var brotliDecompress = promisify(brotliDecompress$1);
var inflate = promisify(inflate$1);
var supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
var decompressPayload = async (rawPayload, headers) => {
  if (rawPayload.length === 0) {
    return;
  }
  const codings = headers.get("content-encoding")?.toLowerCase().split(",").map((x) => x.trim()).reverse() ?? [];
  if (codings.length === 0) {
    return rawPayload;
  }
  const decoders = [];
  for (const [index, coding] of codings.entries()) {
    if (coding === "x-gzip" || coding === "gzip") {
      decoders.push(async (value) => await gunzip(value));
      codings[index] = void 0;
    } else if (coding === "deflate") {
      decoders.push(async (value) => await inflate(value));
      codings[index] = void 0;
    } else if (coding === "br") {
      decoders.push(async (value) => await brotliDecompress(value));
      codings[index] = void 0;
    } else {
      break;
    }
  }
  const remainingCodings = codings.filter((value) => value !== void 0).reverse();
  const payload = await decoders.reduce(
    (previousValue, currentValue) => async (value) => await currentValue(await previousValue(value)),
    async (value) => await Promise.resolve(value)
  )(rawPayload);
  if (remainingCodings.length === 0) {
    headers.delete("content-encoding");
  } else {
    headers.set("content-encoding", remainingCodings.join(","));
  }
  return payload;
};
var redirectStatus = [301, 302, 303, 307, 308];
var last = (list) => list[list.length - 1];
var httpRedirectFetch = async (app, request, options) => {
  const originalURL = new URL(request.url);
  const list = [originalURL];
  const headers = toNodeHeaders(request.headers);
  const payload = Buffer.from(await request.arrayBuffer());
  const method = request.method.toUpperCase();
  const originalResponse = await app.inject({
    headers,
    method,
    payload,
    url: originalURL.toString()
  });
  if (!redirectStatus.includes(originalResponse.statusCode)) {
    return [originalResponse, list];
  }
  if (request.redirect === "manual") {
    return [originalResponse, list];
  }
  if (request.redirect === "error") {
    return "network-error";
  }
  assert(request.redirect === "follow");
  let response = originalResponse;
  while (list.length < 5) {
    const location = fromNodeHeaders(response.headers).get("location");
    if (location == null) {
      return [response, list];
    }
    const url = new URL(location, last(list));
    assertURLSupported(url);
    if (!match(url, request, options)) {
      return "network-error";
    }
    list.push(url);
    response = await app.inject({
      headers,
      method,
      payload,
      url: url.toString()
    });
    if (!redirectStatus.includes(response.statusCode)) {
      return [response, list];
    }
  }
  return "network-error";
};
var hasMatchFunction = (options) => typeof options.match === "function";
var match = (url, request, options) => !hasMatchFunction(options) || // eslint-disable-next-line typescript/no-non-null-assertion
hasMatchFunction(options) && options.match(url, request);
var assertURLSupported = (url) => {
  if (!supportedSchemas.has(url.protocol)) {
    throw new TypeError(`URL scheme "${url.protocol.replace(/:$/, "")}" is not supported.`);
  }
};
var fastifyFetch = (0, import_fastify_plugin.default)(async (app, options = {}) => {
  app.decorate(
    "fetch",
    async (requestInfo, requestInit) => {
      const request = new Request(requestInfo, requestInit);
      const url = new URL(request.url);
      assertURLSupported(url);
      if (url.protocol === "data:") {
        const data = (0, import_data_uri_to_buffer.dataUriToBuffer)(request.url);
        return new Response(data.buffer, {
          headers: { "Content-Type": data.typeFull }
        });
      }
      if (!["DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT"].includes(
        request.method.toUpperCase()
      )) {
        throw new TypeError(`${request.method} is not supported.`);
      }
      if (match(url, request, options)) {
        const result = await httpRedirectFetch(app, request, options);
        if (result === "network-error") {
          return Response.error();
        }
        const [r, list] = result;
        const headers = fromNodeHeaders(r.headers);
        const statusText = r.statusMessage;
        const status = r.statusCode;
        const payload = await decompressPayload(r.rawPayload, headers);
        if (headers.has("Content-Length") && payload !== void 0) {
          const contentLength = payload.byteLength;
          headers.set("Content-Length", contentLength.toString());
        }
        const response = new Response(payload, {
          headers,
          status,
          statusText
        });
        if (list.length > 1) {
          const responseState = getResponseState(response);
          responseState.urlList.push(...list);
        }
        return response;
      } else {
        return await (options.fetch ?? fetch)(request);
      }
    }
  );
});

// src/same-origin.ts
function sameOrigin(A, B) {
  if (A.origin === B.origin && A.origin === "null") {
    return true;
  }
  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
    return true;
  }
  return false;
}

// src/index.ts
var src_default = fastifyFetch;

export { src_default as default, fastifyFetch, fromNodeHeaders, sameOrigin, splitCookiesString, toNodeHeaders };
//# sourceMappingURL=index.js.map
